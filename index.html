<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storekeeper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            height: 100vh;
            background: #121212;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 800px;
            height: 600px;
        }
    </style>
</head>
<body>
    <canvas id="canvas">

    </canvas>
    <script type="module">
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d")

        canvas.width = 800;
        canvas.height = 600;

        let gravity = 5;

        let keys = [];
        let crates = [

        ];

        // window.addEventListener("keydown", (event) => {
         //   if (!keys.includes(event.keyCode)) {
         //       keys.push(event.keyCode)
        //    }
        //})

        window.addEventListener("keydown", (event) => {
            keys[event.keyCode] = true;
        })
        

        window.addEventListener("keyup", (event) => {
            keys[event.keyCode] = false;
        });

        let crateProbability = () => {
            //90% Chance Yellow Crate
            //10% Chance Purple Crate
            let random = 1 + Math.floor(Math.random() * 4);

            if (random === 4) {
                return 4;
            } else if (random < 4) {
                return 1 + Math.floor(Math.random() * 3);
            }
        }

        let cratesX = crates.map((item) => item.x)
        let cratesY = crates.map((item) => item.y);

        class body {
            constructor(x, y, w, h, type) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.type = type;
            }

            render() {
                switch (this.type) {
                    case 1:
                        ctx.fillStyle = "red"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                    case 2:
                        ctx.fillStyle = "yellow"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                    case 3:
                        ctx.fillStyle = "orange"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                    case 4:
                        ctx.fillStyle = "purple"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                }
            }    
        }

        for (let i = 0; i < 1000; i+= 200) {
            crates.push(new body(i, 250, 50, 50, crateProbability()))
        }

        let checkRM = ()  => {return keys[39] || keys[68]};
        let checkUM = ()  => {return keys[32]};
        let checkLM = ()  => {return keys[37] || keys[65]};

        class player {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;

                this.inAir = true;
                this.onCrate = false;
                this.flightPeriod = 0;
            }

            render() {
                ctx.fillStyle = "white"
                ctx.fillRect(this.x,this.y, this.w, this.h);
            }

            collision(o) {
                return (
                    this.x <= o.x + o.w &&
                    this.x + this.w >= o.x &&
                    this.y < o.y + o.h &&
                    this.y + this.h > o.y
                )
            }

            obstruct(o) {
                if (this.x <= o.x) {
                    return "Right"
                } else if (this.x >= o.x) {
                    return "Left"
                }
            }

            get blockedM() {
                let blockedM = [];
                this.flightPeriod += 1; 
                
                if (this.inAir) {
                    blockedM = [];
                    blockedM.push(["Right", "Left"]);
                    if (this.flightPeriod >= 120) {
                        blockedM = [];
                    }
                }

                for (let i = 0; i < crates.length; i++) {
                    let obj = crates[i];

                    let cAbove = false; 
                    let cDown = false;
                    let cRight = false;
                    let cLeft = false;

                    crates.forEach((cr) => {
                        if (cr.x + cr.w >= obj.x && cr.x <= obj.x + obj.w) {
                            if (cr.y === (obj.y - obj.h)) {
                                cAbove = true;
                            } else if (cr.y === (obj.y + obj.h)) {
                                cDown = true;
                            }
                        }

                        if (cr.y === obj.y) {
                            if (cr.x === obj.x + obj.w) {
                                cRight = true;
                            } else if (cr.x === obj.x - obj.w) {
                                cLeft = true;
                            }
                        }
                    });


                    if (this.collision(obj)) {
                        if (!cRight && !cLeft && obj.type !== 4) {

                            if (
                                checkRM() &&
                                this.x + (this.w / 2) <= obj.x &&
                                this.y <= obj.y &&
                                this.y + this.h === obj.y + obj.h &&
                                !cAbove
                            ) {
                                crates[i].x += 5;
                            } else if (
                                checkRM() &&
                                this.y <= obj.y &&
                                this.y + this.h !== obj.y + obj.h
                            ) {
                                if (!blockedM.includes(this.obstruct(obj))) {
                                    blockedM.push(this.obstruct(obj));
                                }
                            }

                            if (
                                checkLM() &&
                                this.x + (this.w / 2) >= obj.x &&
                                this.y <= obj.y &&
                                this.y + this.h === obj.y + obj.h &&
                                !cAbove
                            ) {
                                crates[i].x -= 5;
                            } else if (
                                checkLM() &&
                                this.y <= obj.y &&
                                this.y + this.h !== obj.y + obj.h
                            ) {
                                let dir = this.obstruct(obj);
                                if (!blockedM.includes(dir)) {
                                    blockedM.push(dir);
                                }
                            }

                            if (cAbove) {
                                let dir = this.obstruct(obj);
                                if (!blockedM.includes(dir)) {
                                    blockedM.push(dir);
                                }
                            }

                        } else if (obj.type === 4 || (!cAbove && !cDown)) {
                            let dir = this.obstruct(obj);
                            if (!blockedM.includes(dir)) {
                                blockedM.push(dir);
                            }
                        }

                        if (cRight && checkRM()) {
                            if (!blockedM.includes("Right")) {
                                blockedM.push("Right");
                            }
                        }

                        if (cLeft && checkLM()) {
                            if (!blockedM.includes("Left")) {
                                blockedM.push("Left");
                            }
                        }
                    }

                    if (
                        checkUM() &&
                        this.y - 200 <= obj.y + obj.h &&
                        this.y + this.h  > obj.y + obj.h &&
                        this.x + this.w > obj.x &&
                        this.x < obj.x + obj.w
                    ) {
                        blockedM.push("UP")
                    }
                }

                return blockedM;
            }

        move() {
            const blocked = this.blockedM;

            if (checkUM() && !this.inAir && !blocked.includes("UP")) {
                this.y -= 200;
            }

            if (!(blocked.includes("Right") && blocked.includes("Left"))) {

                if (blocked.length === 0 || (blocked.length === 1 && blocked.includes("UP"))) {
                        
                    if (checkRM()) {
                        this.x += 5;
                    }
                    
                    if (checkLM()) {
                        this.x -= 5;
                    }
                    
                } else if (blocked.includes("Right") ) {

                    if (checkLM()) {
                        this.x -= 5;
                    }
                    
                } else if (blocked.includes("Left")) {
                    if (checkRM()) {
                        this.x += 5;
                    }
                }
            }
        }

    }


        const storekeeper = new player(0, 350, 50, 100);

        
            
        function gameLoop() {
            ctx.clearRect(0, 0, 800, 600);
            
            ctx.fillStyle = "#362D64";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            storekeeper.move();
            storekeeper.render();

            cratesX = crates.map((item) => item.x)
            cratesY = crates.map((item) => item.y);

            crates.forEach(crate => {

                let isSupported = false;

                for (let other of crates) {

                    if (other !== crate) {

                        const directlyUnder =
                            other.y === crate.y + crate.h;

                        const overlapX =
                            crate.x < other.x + other.w &&
                            crate.x + crate.w > other.x;

                        if (directlyUnder && overlapX) {
                            isSupported = true;
                            break;
                        }
                    }
                }

                if (!isSupported && crate.y < 550) {
                    crate.y += gravity;
                }

                crate.render();
            });
            
            for (let z = 0; z < crates.length; z += 1) {
                if (
                    storekeeper.x < crates[z].x + crates[z].w &&
                    storekeeper.x + storekeeper.w > crates[z].x &&
                    storekeeper.y < crates[z].y + crates[z].h &&
                    storekeeper.y + storekeeper.h >= crates[z].y &&
                    storekeeper.y + storekeeper.h <= crates[z].y + (crates[z].h / 2)
                ) {
                    storekeeper.onCrate = true;
                    break; //By the Principal of Non Super imposition
                } else {
                    storekeeper.onCrate = false;
                }
                
            }
            if (!(storekeeper.y === 500 || storekeeper.onCrate)){
                storekeeper.inAir = true;
                storekeeper.y += gravity;
            } else {
                storekeeper.inAir = false;
            }


            window.requestAnimationFrame(gameLoop)
        }

        window.setInterval(() => {
            for (let i = 0; i < 800; i+= 300) {
                crates.push(new body(i, 10, 50, 50, crateProbability()))
            }
        }, 8000);
        
        gameLoop();
        
    </script>
</body>
</html>