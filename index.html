<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storekeeper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            height: 100vh;
            background: #121212;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 800px;
            height: 600px;
        }
    </style>
</head>
<body>
    <canvas id="canvas">

    </canvas>
    <script type="module">
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d")

        canvas.width = 800;
        canvas.height = 600;

        let gravity = 5;
        const pProps = {
            px: 0,
            py: 0,
        }

        let keys = [];
        let crates = [

        ];

        window.addEventListener("keydown", (event) => {
            if (!keys.includes(event.keyCode)) {
                keys.push(event.keyCode)
            }
        })

        window.addEventListener("keyup", (event) => {
            let a = keys.indexOf(event.keyCode)
            keys.splice(a, 1);
        });

        let crateProbability = () => {
            //90% Chance Yellow Crate
            //10% Chance Purple Crate
            let random = 1 + Math.floor(Math.random() * 4);

            if (random === 4) {
                return 4;
            } else if (random < 4) {
                return 1 + Math.floor(Math.random() * 3);
            }
        }

        let cratesX = crates.map((item) => item.x)
        let cratesY = crates.map((item) => item.y);

        class body {
            constructor(x, y, w, h, type) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.type = type;
            }

            render() {
                switch (this.type) {
                    case 1:
                        ctx.fillStyle = "red"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                    case 2:
                        ctx.fillStyle = "yellow"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                    case 3:
                        ctx.fillStyle = "orange"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                    case 4:
                        ctx.fillStyle = "purple"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                    break;

                }
            }    
        }

        for (let i = 0; i < 1000; i+= 200) {
            crates.push(new body(i, 250, 50, 50, crateProbability()))
        }

        let checkRM = ()  => {return keys.includes(39) || keys.includes(68)};
        let checkLM = ()  => {return keys.includes(37) || keys.includes(65)};

        class player {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;

                this.inAir = true;
                this.onCrate = false;
            }

            render() {
                ctx.fillStyle = "red"
                ctx.fillRect(this.x,this.y, this.w, this.h);
            }

            collision(o) {
                return (
                    this.x <= o.x + o.w &&
                    this.x + this.w >= o.x &&
                    this.y < o.y + o.h &&
                    this.y + this.h > o.y
                )
            }

            get blockedM() {
                let blockedM = "";

                for (let i = 0; i < crates.length; i++) {
                    let obj = crates[i];
                    

                    //We Know the exact index of block that is left or right to current block
                    //But checking just which block is to 
                    
                    let cAbove; 
                    let cDown;
                    let cRight;
                    let cLeft;
                    crates.forEach((cr) => {
                        if (cr.x + cr.w >= obj.x && cr.x  <= obj.x + obj.w){
                            if (cr.y === (obj.y - obj.h)) {
                                cAbove = true;
                            } else if (cr.y === (obj.y + obj.h)) {
                                cDown = true;
                            }
                        }

                        if (cr.y === obj.y) {
                            if (cr.x === obj.x + obj.w) {
                                cRight  = true;
                            } else if (cr.x === obj.x - obj.w) {
                                cLeft = true;
                            }
                        }
                    })


                    if (this.collision(obj)) {
                        if (!cRight && !cLeft && obj.type !== 4) {
                            if (
                                checkRM
                                && this.x + (this.w / 2) < obj.x
                                && this.y <= obj.y
                                && this.y + (this. h) === obj.y + obj.h
                                && !cAbove
                            ) {
                                crates[i].x += 5;
                            } 
                            
                            if (
                                checkLM 
                                && this.x + (this.w / 2) > obj.x
                                && this.y <= obj.y
                                && this.y + (this. h) === obj.y + obj.h
                                && !cAbove
                            ) {
                                crates[i].x -= 5;
                            }

                            if (cAbove) {
                                if (this.x <= obj.x) {
                                    blockedM = "Right"
                                } else if (this.x >= obj.x) {
                                    blockedM = "Left"
                                }
                            }

                            if (cDown) {
                                if (this.x <= obj.x) {
                                    blockedM = "Right"
                                } else if (this.x >= obj.x) {
                                    blockedM = "Left"
                                }
                            }
                        } else if (obj.type === 4 || (!cAbove && !cDown)) {
                            if (this.x <= obj.x) {
                                blockedM = "Right"
                            } else if (this.x >= obj.x) {
                                blockedM = "Left"
                            }
                        }

                        if (cRight && checkRM) {
                            blockedM = 'Right';
                        } 

                        if (cLeft && checkLM) {
                            blockedM = 'Left';
                        }
                    }
                }

                return blockedM;
                
            }

            move() {
                if (keys.includes(32) && !storekeeper.inAir) {
                    this.y -= 200;
                } 
                
                if (this.blockedM === "") {
                    if (keys.includes(39) || keys.includes(68)) {
                        this.x += 5;
                    } 
                    
                    if (keys.includes(37) || keys.includes(65)) {
                        this.x -= 5;
                    }
                } else if (this.blockedM === "Right") {
                    if (keys.includes(37) || keys.includes(65)) {
                        this.x -= 5;
                    }
                } else if (this.blockedM === "Left") {
                    if (keys.includes(39) || keys.includes(68)) {
                        this.x += 5;
                    }
                } else if (this.blockedM === "ALL") {

                }
            }
        }

        const storekeeper = new player(0, 350, 50, 100);

        
            
        function gameLoop() {
            ctx.clearRect(0, 0, 800, 600);
            
            ctx.fillStyle = "#362D64";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            storekeeper.move();
            storekeeper.render();

            cratesX = crates.map((item) => item.x)
            cratesY = crates.map((item) => item.y);

            crates.forEach(crate => {

                let isSupported = false;

                for (let other of crates) {

                    if (other !== crate) {

                        const directlyUnder =
                            other.y === crate.y + crate.h;

                        const overlapX =
                            crate.x < other.x + other.w &&
                            crate.x + crate.w > other.x;

                        if (directlyUnder && overlapX) {
                            isSupported = true;
                            break;
                        }
                    }
                }

                if (!isSupported && crate.y < 550) {
                    crate.y += gravity;
                }

                crate.render();
            });
            
            for (let z = 0; z < crates.length; z += 1) {
                if (
                    storekeeper.x < crates[z].x + crates[z].w &&
                    storekeeper.x + storekeeper.w > crates[z].x &&
                    storekeeper.y < crates[z].y + crates[z].h &&
                    storekeeper.y + storekeeper.h >= crates[z].y &&
                    storekeeper.y + storekeeper.h <= crates[z].y + (crates[z].h / 2)
                ) {
                    storekeeper.onCrate = true;
                    break; //By the Principal of Non Super imposition
                } else {
                    storekeeper.onCrate = false;
                }
                
            }
            if (!(storekeeper.y === 500 || storekeeper.onCrate)){
                storekeeper.inAir = true;
                storekeeper.y += gravity;
            } else {
                storekeeper.inAir = false;
            }


            window.requestAnimationFrame(gameLoop)
        }

        window.setInterval(() => {
            for (let i = 0; i < 1000; i+= 200) {
                crates.push(new body(i, 250, 50, 50, crateProbability()))
            }
        }, 4000);
        
        gameLoop();
        
    </script>
</body>
</html>