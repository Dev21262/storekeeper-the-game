<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storekeeper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            height: 100vh;
            background: #121212;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 800px;
            height: 600px;
        }
    </style>
</head>
<body>
    <canvas id="canvas">

    </canvas>
    <script type="module">
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d")

        canvas.width = 800;
        canvas.height = 600;

        let gravity = 5;
        const pProps = {
            px: 0,
            py: 0,
        }

        let keys = [];
        let crates = [

        ];

        window.addEventListener("keydown", (event) => {
            if (!keys.includes(event.keyCode)) {
                keys.push(event.keyCode)
            }
        })

        window.addEventListener("keyup", (event) => {
            let a = keys.indexOf(event.keyCode)
            keys.splice(a, 1);
        });

        let crateProbability = () => {
            //90% Chance Yellow Crate
            //10% Chance Purple Crate
            let random = 1 + Math.floor(Math.random() * 4);

            if (random === 4) {
                return 4;
            } else if (random < 4) {
                return 1 + Math.floor(Math.random() * 3);
            }
        }

        let cratesX = crates.map((item) => item.x)
        let cratesY = crates.map((item) => item.y);

        class body {
            constructor(x, y, w, h, type) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.type = type;
            }

            render() {
                switch (this.type) {
                    case 1:
                        ctx.fillStyle = "red"
                        ctx.strokeStyle = "purple"
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.stroke();
                    break;

                    case 2:
                        ctx.fillStyle = "yellow"
                        ctx.strokeStyle = "purple"
                        ctx.lineWidth = 5
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.strokeRect(this.x, this.y, this.w, this.h);
                        ctx.stroke();
                    break;

                    case 3:
                        ctx.fillStyle = "orange"
                        ctx.strokeStyle = "purple"
                        ctx.lineWidth = 5
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.strokeRect(this.x, this.y, this.w, this.h);
                        ctx.stroke();
                    break;

                    case 4:
                        ctx.fillStyle = "purple"
                        ctx.strokeStyle = "purple"
                        ctx.lineWidth = 5
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.strokeRect(this.x, this.y, this.w, this.h);
                        ctx.stroke();
                    break;

                }
            }    
        }

        for (let i = 0; i < 1000; i+= 150) {
            crates.push(new body(i, 250, 50, 50, crateProbability()))
            console.log(crates);
        }

        let checkRM = ()  => {return keys.includes(39) || keys.includes(68)};
        let checkLM = ()  => {return keys.includes(37) || keys.includes(65)};

        class player {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.onCrate = false;
                this.inAir = true;
            }

            render() {
                ctx.fillStyle = "red"
                ctx.fillRect(this.x,this.y, this.w, this.h);
            }

            get blockedM() {
                let blockedM = "";

                for (let i = 0; i < crates.length; i++) {
                    let obj = crates[i];

                    let c2xR = cratesX.indexOf(obj.x + obj.w);
                    let c2xL = cratesX.indexOf(obj.x - obj.w);

                    if (
                        this.x < obj.x + obj.w &&
                        this.x + this.w >= obj.x &&
                        this.y < obj.y + obj.h &&
                        this.y + this.h > obj.y
                    ) {

                        if (c2xR === -1 && c2xL === -1 && obj.type !== 4) {
                            if (
                                checkRM
                                && this.x + (this.w / 2) < obj.x + (obj.w / 2)
                                && this.y + (this. h) > obj.y
                            ) {
                                crates[i].x += 5;
                                console.log("Crate moved to the right")
                            } else if (
                                checkLM 
                                && this.x + (this.w / 2) > obj.x + (obj.w / 2)
                                && this.y + (this. h) > obj.y
                            ) {
                                crates[i].x -= 5;
                            }
                        } else if (obj.type === 4) {
                            if (this.x < obj.x) {
                                blockedM = "Right"
                            } else if (this.x > obj.x) {
                                blockedM = "Left"
                            }
                        }

                        if (c2xR !== -1 && checkRM) {
                            blockedM = 'Right';
                        } 

                        if (c2xL !== -1 && checkLM) {
                            blockedM = 'Left';
                        }
                    }
                }

                return blockedM;
                
            }

            move() {
                if (keys.includes(32) && !storekeeper.inAir) {
                    this.y -= 100;
                    console.log("Jumped")
                } 
                
                if (this.blockedM === "") {
                    if (keys.includes(39) || keys.includes(68)) {
                        this.x += 5;
                    } else if (keys.includes(37) || keys.includes(65)) {
                        this.x -= 5;
                    }
                } else if (this.blockedM === "Right") {
                    if (keys.includes(37) || keys.includes(65)) {
                        this.x -= 5;
                    }
                } else if (this.blockedM === "Left") {
                    if (keys.includes(39) || keys.includes(68)) {
                        this.x += 5;
                    }
                } else if (this.blockedM === "ALL") {

                }
            }
        }

        const storekeeper = new player(0, 350, 50, 100);

        
            
        function gameLoop() {
            ctx.clearRect(0, 0, 800, 600);
            
            ctx.fillStyle = "#362D64";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            storekeeper.move();
            storekeeper.render();

            cratesX = crates.map((item) => item.x)
            cratesY = crates.map((item) => item.y);

            crates.forEach((crate, index) => {
                let c2yD = cratesY.indexOf(crate.y + crate.h);
                let c2yU = cratesY.indexOf(crate.y - crate.h);
                const mCrates = cratesY.slice(index, 1);

                let cx = mCrates.indexOf(crate.x);

                if (c2yD === -1 && cx === -1) {
                    if (crate.y < 550) {
                        crate.y += 10;
                    }
                }

                crate.render();
            });
            
            for (let z = 0; z < crates.length; z += 1) {
                                                                
                if (
                    storekeeper.x < crates[z].x + crates[z].w &&
                    storekeeper.x + storekeeper.w > crates[z].x &&
                    storekeeper.y < crates[z].y + crates[z].h &&
                    storekeeper.y + storekeeper.h >= crates[z].y &&
                    storekeeper.y + storekeeper.h <= crates[z].y + (crates[z].h / 2)
                ) {
                    storekeeper.inAir = false;
                    storekeeper.onCrate = true;
                    break; //By the Principal of Non Super imposition
                } else {
                    storekeeper.onCrate = false;
                    storekeeper.inAir = true;
                }
                
            }
            if (!(storekeeper.y === 500 || storekeeper.onCrate)){
                storekeeper.inAir = true;
                storekeeper.y += gravity;
            } else {
                storekeeper.inAir = false;
            }


            window.requestAnimationFrame(gameLoop)
        }
        
        gameLoop();
        
    </script>
</body>
</html>